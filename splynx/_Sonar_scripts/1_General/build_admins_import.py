#!/usr/bin/env python3
"""
Transform Sonar users.csv -> admins_import.csv for MySQL import.

Features:
- Ensures unique emails (suffix at the end): duplicate@example.com -> duplicate@example.com2
- Ensures unique logins (suffix at the end): login -> login2
- Placeholder for empty values: email -> "no-email", login -> "user"
- Optional hashing mode (--hash sha256|bcrypt). Default sha256.
  * sha256: CSV keeps plain password (username); SQL will hash with SHA2(...,256)
  * bcrypt: CSV stores bcrypt hashes; SQL inserts as-is
- Optional SQL emitters:
  --emit-sql           -> MySQL script that uses LOAD DATA LOCAL INFILE
  --emit-adminer-sql   -> Single-file SQL with inline INSERTs (for Adminer upload)

Usage:
  python build_admins_import.py --input users.csv --output admins_import.csv \
      --hash sha256 --emit-sql import_admins.sql --emit-adminer-sql import_adminer.sql
"""
import argparse
import sys
import pandas as pd
from pathlib import Path

def resolve_col(df, name_guess: str) -> str:
    cols = {c.strip().lower(): c for c in df.columns}
    key = name_guess.strip().lower()
    if key in cols:
        return cols[key]
    # try ignoring spaces
    for k, c in cols.items():
        if k.replace(" ", "") == key.replace(" ", ""):
            return c
    raise KeyError(f"Column '{name_guess}' not found. Available: {list(df.columns)}")

def ensure_unique_suffix(series: pd.Series, empty_placeholder: str) -> pd.Series:
    seen = {}
    result = []
    for raw in series.astype(str).tolist():
        val = (raw or "").strip()
        if val == "":
            val = empty_placeholder
        candidate = val
        n = seen.get(candidate.lower(), 0)
        if n == 0:
            unique = candidate
        else:
            while True:
                n += 1
                unique = f"{candidate}{n}"
                if unique.lower() not in seen:
                    break
        seen[unique.lower()] = n
        result.append(unique)
    return pd.Series(result)

def bcrypt_hash_series(series: pd.Series) -> pd.Series:
    try:
        import bcrypt
    except Exception as e:
        raise RuntimeError("bcrypt module not available. Install 'bcrypt' to use --hash bcrypt.") from e
    out = []
    for v in series.astype(str).tolist():
        raw = (v or "").encode("utf-8")
        if raw == b"":
            raw = b"user"
        hashed = bcrypt.hashpw(raw, bcrypt.gensalt())
        out.append(hashed.decode("utf-8"))
    return pd.Series(out)

def build_sql(csv_path: str, hash_mode: str) -> str:
    csv_sql_path = csv_path.replace("\\", "\\\\")
    password_expr = "SHA2(s.password, 256)" if hash_mode == "sha256" else "s.password"
    sql = f"""
-- Auto-generated by build_admins_import.py
-- CSV source: {csv_sql_path}
-- Hash mode: {hash_mode}

CREATE TABLE IF NOT EXISTS admins_import_stage (
  id            INT UNSIGNED,
  partner_id    INT UNSIGNED,
  role_name     VARCHAR(32),
  login         VARCHAR(64),
  name          VARCHAR(64),
  email         VARCHAR(64),
  password      VARCHAR(512),
  phone         VARCHAR(256)
) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
TRUNCATE TABLE admins_import_stage;

LOAD DATA LOCAL INFILE '{csv_sql_path}'
INTO TABLE admins_import_stage
FIELDS TERMINATED BY ',' ENCLOSED BY '\"' ESCAPED BY '\"'
LINES TERMINATED BY '\\n'
IGNORE 1 LINES
(id, partner_id, role_name, login, name, email, password, phone);

INSERT IGNORE INTO roles (name) VALUES ('administrator'), ('super-administrator');

START TRANSACTION;
DROP TEMPORARY TABLE IF EXISTS _conflicts;
SET @mx := GREATEST(
  (SELECT COALESCE(MAX(id), 0) FROM admins),
  (SELECT COALESCE(MAX(id), 0) FROM admins_import_stage)
);
CREATE TEMPORARY TABLE _conflicts (old_id INT UNSIGNED PRIMARY KEY, new_id INT UNSIGNED);
INSERT INTO _conflicts (old_id, new_id)
SELECT a.id AS old_id, (@mx := @mx + 1) AS new_id
FROM admins a
JOIN admins_import_stage s ON s.id = a.id
ORDER BY a.id;
UPDATE admins a
JOIN _conflicts c ON c.old_id = a.id
SET a.id = c.new_id;
COMMIT;

START TRANSACTION;
INSERT INTO admins
(id, partner_id, role_name, router_access, login, name, email, password, otp_secret,
 timeout, deleted, last_ip, last_dt, phone, photo_version, default_photo, send_from_my_name, updated_at, calendar_color)
SELECT
  s.id,
  COALESCE(s.partner_id, 0),
  CASE WHEN s.role_name='super-administrator' THEN 'super-administrator' ELSE 'administrator' END,
  'none',
  s.login,
  s.name,
  s.email,
  {password_expr},
  NULL,
  0,
  '0',
  NULL,
  NULL,
  s.phone,
  NULL,
  0,
  '0',
  CURRENT_TIMESTAMP,
  NULL
FROM admins_import_stage s
ON DUPLICATE KEY UPDATE
  partner_id = VALUES(partner_id),
  role_name  = VALUES(role_name),
  router_access = VALUES(router_access),
  login      = VALUES(login),
  name       = VALUES(name),
  email      = VALUES(email),
  password   = VALUES(password),
  phone      = VALUES(phone),
  updated_at = VALUES(updated_at);
COMMIT;
""".strip() + "\n"
    return sql

def sql_escape(value: str) -> str:
    if value is None or (isinstance(value, float) and pd.isna(value)):
        return "NULL"
    v = str(value).replace("\\", "\\\\").replace("'", "\\'")
    return f"'{v}'"

def build_adminer_sql(rows, hash_mode: str) -> str:
    password_expr = "SHA2(s.password, 256)" if hash_mode == "sha256" else "s.password"
    lines = []
    lines.append("-- Adminer-friendly SQL (no LOAD DATA). Auto-generated.")
    lines.append("CREATE TABLE IF NOT EXISTS admins_import_stage ("
                 "id INT UNSIGNED, partner_id INT UNSIGNED, role_name VARCHAR(32), "
                 "login VARCHAR(64), name VARCHAR(64), email VARCHAR(64), "
                 "password VARCHAR(512), phone VARCHAR(256)"
                 ") CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;")
    lines.append("TRUNCATE TABLE admins_import_stage;")

    batch_size = 500
    batch = []
    def flush_batch():
        if not batch:
            return
        values = ",".join(batch)
        lines.append("INSERT INTO admins_import_stage "
                     "(id, partner_id, role_name, login, name, email, password, phone) VALUES " + values + ";")
        batch.clear()

    for r in rows:
        vals = [
            "NULL" if pd.isna(r.get("id")) else str(int(r.get("id"))),
            "0" if pd.isna(r.get("partner_id")) else str(int(r.get("partner_id"))),
            sql_escape(r.get("role_name")),
            sql_escape(r.get("login")),
            sql_escape(r.get("name")),
            sql_escape(r.get("email")),
            sql_escape(r.get("password")),
            sql_escape(r.get("phone")),
        ]
        batch.append("(" + ",".join(vals) + ")")
        if len(batch) >= batch_size:
            flush_batch()
    flush_batch()

    lines.append("INSERT IGNORE INTO roles (name) VALUES ('administrator'), ('super-administrator');")
    lines.append("START TRANSACTION;")
    lines.append("DROP TEMPORARY TABLE IF EXISTS _conflicts;")
    lines.append("SET @mx := GREATEST((SELECT COALESCE(MAX(id), 0) FROM admins), (SELECT COALESCE(MAX(id), 0) FROM admins_import_stage));")
    lines.append("CREATE TEMPORARY TABLE _conflicts (old_id INT UNSIGNED PRIMARY KEY, new_id INT UNSIGNED);")
    lines.append("INSERT INTO _conflicts (old_id, new_id) "
                 "SELECT a.id AS old_id, (@mx := @mx + 1) AS new_id FROM admins a "
                 "JOIN admins_import_stage s ON s.id = a.id ORDER BY a.id;")
    lines.append("UPDATE admins a JOIN _conflicts c ON c.old_id = a.id SET a.id = c.new_id;")
    lines.append("COMMIT;")

    lines.append("START TRANSACTION;")
    lines.append("INSERT INTO admins "
                 "(id, partner_id, role_name, router_access, login, name, email, password, otp_secret, "
                 " timeout, deleted, last_ip, last_dt, phone, photo_version, default_photo, send_from_my_name, updated_at, calendar_color) "
                 "SELECT s.id, COALESCE(s.partner_id,0), "
                 "CASE WHEN s.role_name='super-administrator' THEN 'super-administrator' ELSE 'administrator' END, "
                 "'none', s.login, s.name, s.email, " + password_expr + ", "
                 "NULL, 0, '0', NULL, NULL, s.phone, NULL, 0, '0', CURRENT_TIMESTAMP, NULL "
                 "FROM admins_import_stage s "
                 "ON DUPLICATE KEY UPDATE "
                 "partner_id=VALUES(partner_id), role_name=VALUES(role_name), router_access=VALUES(router_access), "
                 "login=VALUES(login), name=VALUES(name), email=VALUES(email), password=VALUES(password), "
                 "phone=VALUES(phone), updated_at=VALUES(updated_at);")
    lines.append("COMMIT;")
    return "\n".join(lines) + "\n"

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--input", "-i", required=True, help="Path to users.csv from Sonar")
    ap.add_argument("--output", "-o", required=True, help="Path to write admins_import.csv")
    ap.add_argument("--hash", choices=["sha256", "bcrypt"], default="sha256", help="Password hashing mode")
    ap.add_argument("--emit-sql", help="Path to write a MySQL script that uses LOAD DATA")
    ap.add_argument("--emit-adminer-sql", help="Path to write a single-file SQL with inline INSERTs (for Adminer upload)")
    args = ap.parse_args()

    # Read CSV
    try:
        df = pd.read_csv(args.input)
    except Exception:
        try:
            df = pd.read_csv(args.input, sep=";")
        except Exception as e:
            print(f"Failed to read CSV: {e}", file=sys.stderr)
            sys.exit(1)

    # Resolve columns
    col_id = resolve_col(df, "ID")
    col_username = resolve_col(df, "username")
    col_name = resolve_col(df, "name")
    col_email = resolve_col(df, "email address")
    col_mobile = resolve_col(df, "mobile number")
    col_super_admin = resolve_col(df, "super admin")

    out = pd.DataFrame()
    out["id"] = df[col_id]
    out["partner_id"] = 0
    out["role_name"] = pd.to_numeric(df[col_super_admin], errors="coerce").fillna(0).astype(int).apply(
        lambda x: "super-administrator" if x == 1 else "administrator"
    )
    out["login"] = ensure_unique_suffix(df[col_username], empty_placeholder="user")
    out["name"] = df[col_name]
    out["email"] = ensure_unique_suffix(df[col_email], empty_placeholder="no-email")

    if args.hash == "bcrypt":
        out["password"] = bcrypt_hash_series(df[col_username])
    else:
        out["password"] = df[col_username].fillna("").astype(str).replace({"": "user"})

    out["phone"] = df[col_mobile]

    # Write CSV
    Path(args.output).parent.mkdir(parents=True, exist_ok=True)
    out.to_csv(args.output, index=False, encoding="utf-8")
    print(f"Wrote {len(out)} rows to {args.output}")

    # Emit SQL scripts
    if args.emit_sql:
        sql_text = build_sql(args.output, args.hash)
        Path(args.emit_sql).write_text(sql_text, encoding="utf-8")
        print(f"Wrote SQL script to {args.emit_sql}")

    if args.emit_adminer_sql:
        sql_text2 = build_adminer_sql(out.to_dict(orient="records"), args.hash)
        Path(args.emit_adminer_sql).write_text(sql_text2, encoding="utf-8")
        print(f"Wrote Adminer SQL script to {args.emit_adminer_sql}")

if __name__ == "__main__":
    main()
